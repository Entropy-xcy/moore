// Copyright (c) 2016 Fabian Schuiki
// A parser generator for LALR(1) grammars.
use std::fs::File;
use std::io::Write;
use std::collections::HashMap;
use std::path::Path;
mod grammar;
mod states;
use pargen::states::Action;
use pargen::grammar::Symbol;


pub fn generate(grammar_path: &Path, output_path: &Path) {

	// Parse the grammar.
	let grammar = grammar::parse(grammar_path);
	println!("{:?}", *grammar.borrow());

	// Translate the grammar into the state machine that recognizes it.
	let states = states::translate(&grammar.borrow());

	// // Generate the output rust code.
	let mut f = File::create(output_path).unwrap();
	write!(f, "// Parser for {}\n", grammar_path.to_str().unwrap()).unwrap();
	write!(f, "// Automatically generated by pargen.rs\n").unwrap();

	for state in &states {
		write!(f, "\n\n// State {}\n", state.id).unwrap();
		for lead in &state.leads {
			write!(f, "//   {:?}\n", lead).unwrap();
		}

		write!(f, "fn action_{}(item: &Item) -> Action {{\n", state.id).unwrap();
		// write!(f, "\tprintln!(\"state {}\");\n", state.id).unwrap();
		write!(f, "\tmatch item {{\n").unwrap();
		for (sym, action) in &state.actions {
			match sym {
				&Symbol::Terminal(ref name) => write!(f, "\t\t&Item::Shifted({}) => ", grammar.borrow().get_pattern(name)),
				&Symbol::NonTerminal(ref rule_weak) => {
					let rule = rule_weak.upgrade().unwrap();
					let o = write!(f, "\t\t&Item::Reduced(RuleId::{}, _) => ", rule.borrow().get_name());
					o
				},
				&Symbol::End => write!(f, "\t\t&Item::End => "),
				_ => panic!("Unknown symbol {:?}", sym),
			}.unwrap();
			match action {
				&Action::Shift(id) => write!(f, "Action::Shift(action_{}),\n", id),
				&Action::Goto(id) => write!(f, "Action::Goto(action_{}),\n", id),
				&Action::Reduce(ref var_cell) => {
					let var = var_cell.borrow();
					let rule = var.rule.upgrade().unwrap();
					let o = write!(f, "Action::Reduce(RuleId::{}, {}, reduce_{}),\n", rule.borrow().get_name(), var.get_symbols().len(), var.id);
					o
				},
			}.unwrap();
		}
		write!(f, "\t\t_ => panic!(\"syntax error, unexpected {{:?}}\", item),\n").unwrap();
		write!(f, "\t}}\n").unwrap();
		write!(f, "}}\n").unwrap();
	}


	// Reduction types.
	let retypes = {
		let mut hm = HashMap::new();
		let mut i = 0;
		for rule in &grammar.borrow().rules {
			if let Some(ref retype) = rule.borrow().retype {
				hm.entry(retype.clone()).or_insert_with(|| {
					i += 1;
					i
				});
			}
		}
		hm
	};

	write!(f, "\n// Reduction Types\n").unwrap();
	write!(f, "#[derive(Debug)]\n").unwrap();
	write!(f, "enum Reduction {{\n").unwrap();
	for (ty,id) in &retypes {
		write!(f, "\tTy{}({}),\n", id, ty).unwrap();
	}
	write!(f, "\tNone,\n").unwrap();
	write!(f, "}}\n").unwrap();


	// Reduction functions.
	write!(f, "\n// Reduction Functions\n").unwrap();
	for rule in &grammar.borrow().rules {
		for var in &rule.borrow().variants {
			write!(f, "\n// {} â†’ {:?}\n", rule.borrow().name, var.borrow()).unwrap();
			write!(f, "#[allow(unused_mut,unused_variables)]\n").unwrap();
			write!(f, "fn reduce_{}(mut items: Vec<Item>) -> Reduction {{\n", var.borrow().id).unwrap();

			let red = &var.borrow().reducer;
			if let &Some(ref redname) = red {
				write!(f, "\tlet mut it = items.drain(..);\n").unwrap();

				let syms = &var.borrow().symbols;
				let mut i = 0;
				for sym in syms {
					write!(f, "\tlet mut item{} = match it.next().unwrap() {{\n", i).unwrap();
					match &*sym.borrow() {
						&Symbol::Terminal(_) => {
							write!(f, "\t\tItem::Shifted(tkn) => tkn,\n").unwrap();
						},
						&Symbol::NonTerminal(ref rule_cell) => {
							let rule = rule_cell.upgrade().unwrap();
							if let Some(ref retype) = rule.borrow().retype {
								write!(f, "\t\tItem::Reduced(RuleId::{}, Reduction::Ty{}(red)) => red,\n", rule.borrow().name, retypes[retype]).unwrap();
							} else {
								write!(f, "\t\tItem::Reduced(RuleId::{}, red) => red,\n", rule.borrow().name).unwrap();
							};
						},
						x => panic!("unsupported symbol {:?}", x),
					}
					write!(f, "\t\t_ => panic!(\"unexpected item\")\n").unwrap();
					write!(f, "\t}};\n").unwrap();
					i += 1;
				}

				if let Some(ref retype) = rule.borrow().retype {
					write!(f, "\tReduction::Ty{}(", retypes[retype]).unwrap();
				}
				write!(f, "{}(", redname).unwrap();
				for i in 0..syms.len() {
					if i > 0 {
						write!(f, ", ").unwrap();
					}
					write!(f, "item{}", i).unwrap();
				}
				if rule.borrow().retype.is_some() {
					write!(f, ")").unwrap();
				}
				write!(f, ")\n").unwrap();
			} else {
				let syms = &var.borrow().symbols;
				let mut i = 0;
				let mut handled = false;
				for sym in syms {
					match &*sym.borrow() {
						&Symbol::Terminal(_) => (),
						&Symbol::NonTerminal(ref rule_cell) => {
							let rule = &*rule_cell.upgrade().unwrap();
							write!(f, "\tmatch items.remove({}) {{\n", i).unwrap();
							write!(f, "\t\tItem::Reduced(RuleId::{}, red) => red,\n", rule.borrow().name).unwrap();
							write!(f, "\t\t_ => panic!(\"unexpected item\")\n").unwrap();
							write!(f, "\t}}\n").unwrap();
							handled = true;
							break;
						},
						x => panic!("unsupported symbol {:?}", x),
					}
					i += 1;
				}

				if !handled {
					write!(f, "\tReduction::None\n").unwrap();
				}
			}
			write!(f, "}}\n").unwrap();
		}
	}


	write!(f, "\n// Rule Identifiers\n").unwrap();
	write!(f, "#[derive(Debug)]\n").unwrap();
	write!(f, "#[allow(non_camel_case_types)]\n").unwrap();
	write!(f, "enum RuleId {{\n").unwrap();
	for rule_cell in &grammar.borrow().rules {
		write!(f, "\t{},\n", rule_cell.borrow().name).unwrap();
	}
	write!(f, "}}\n").unwrap();
}

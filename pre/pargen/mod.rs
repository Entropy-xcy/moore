// Copyright (c) 2016-2017 Fabian Schuiki
// A parser generator for LALR(1) grammars.
use std::fs::File;
use std::io::Write;
use std::collections::HashMap;
use std::path::Path;
mod grammar;
mod states;
mod lexer;
mod parser;
// mod new_grammar;
use pargen::states::Action;
use pargen::grammar::Symbol;


pub fn generate(grammar_path: &Path, output_path: &Path) {
	// TODO(fabianschuiki): Make this function return an IO result and use the
	// try!() macro ratherh than .unwrap() everywhere.

	// Parse the grammar.
	let grammar = parser::parse(grammar_path);
	println!("{:?}", grammar);

	// Translate the grammar into the state machine that recognizes it.
	let states = states::translate(&grammar);
	println!("States translated");

	// // Generate the output rust code.
	let mut f = File::create(output_path).unwrap();
	write!(f, "// Parser for {}\n", grammar_path.to_str().unwrap()).unwrap();
	write!(f, "// Automatically generated by pargen.rs\n").unwrap();

	for state in &states {
		write!(f, "\n\n// State {}\n", state.get_id()).unwrap();
		for lead in state.leads() {
			write!(f, "//   {:?}\n", lead).unwrap();
		}

		write!(f, "fn action_{}(item: &Item) -> Action {{\n", state.get_id()).unwrap();
		// write!(f, "\tprintln!(\"state {}\");\n", state.id).unwrap();
		write!(f, "\tmatch item {{\n").unwrap();
		for (sym, action) in state.actions() {
			match *sym {
				Symbol::Terminal(ref name) => write!(f, "\t\t&Item::Shifted({}) => ", grammar.get_pattern(name)),
				Symbol::NonTerminal(rule) => {
					let o = write!(f, "\t\t&Item::Reduced(RuleId::{}, _) => ", rule.get_name());
					o
				},
				Symbol::End => write!(f, "\t\t&Item::End => "),
				_ => panic!("Unknown symbol {:?}", sym),
			}.unwrap();
			match *action {
				Action::Shift(id) => write!(f, "Action::Shift(action_{}),\n", id),
				Action::Goto(id) => write!(f, "Action::Goto(action_{}),\n", id),
				Action::Reduce(var) => {
					let o = write!(f, "Action::Reduce(RuleId::{}, {}, reduce_{}),\n",
						var.get_rule().get_name(),
						var.symbols().len(),
						var.get_id(),
					);
					o
				},
			}.unwrap();
		}
		write!(f, "\t\t_ => panic!(\"syntax error, unexpected {{:?}}\", item),\n").unwrap();
		write!(f, "\t}}\n").unwrap();
		write!(f, "}}\n").unwrap();
	}


	// Reduction types.
	let retypes = {
		let mut hm = HashMap::new();
		let mut i = 0;
		for rule in grammar.rules() {
			if let Some(ref rt) = rule.get_reduced_type() {
				hm.entry(rt.clone()).or_insert_with(|| {
					i += 1;
					i
				});
			}
		}
		hm
	};

	write!(f, "\n// Reduction Types\n").unwrap();
	write!(f, "#[derive(Debug)]\n").unwrap();
	write!(f, "enum Reduction {{\n").unwrap();
	for (ty,id) in &retypes {
		write!(f, "\tTy{}({}),\n", id, ty).unwrap();
	}
	write!(f, "\tNone,\n").unwrap();
	write!(f, "}}\n").unwrap();


	// Reduction functions.
	write!(f, "\n// Reduction Functions\n").unwrap();
	for rule in grammar.rules() {
		for var in rule.variants() {
			write!(f, "\n// {} â†’ {:?}\n", rule.get_name(), var).unwrap();
			write!(f, "#[allow(unused_mut,unused_variables)]\n").unwrap();
			write!(f, "fn reduce_{}(mut items: Vec<Item>) -> Reduction {{\n", var.get_id()).unwrap();

			if let Some(redname) = var.get_reducer_fn() {
				write!(f, "\tlet mut it = items.drain(..);\n").unwrap();

				let mut i = 0;
				for sym in var.symbols() {
					write!(f, "\tlet mut item{} = match it.next().unwrap() {{\n", i).unwrap();
					match *sym {
						Symbol::Terminal(_) => {
							write!(f, "\t\tItem::Shifted(tkn) => tkn,\n").unwrap();
						},
						Symbol::NonTerminal(rule) => {
							if let Some(ref retype) = rule.get_reduced_type() {
								write!(f, "\t\tItem::Reduced(RuleId::{}, Reduction::Ty{}(red)) => red,\n", rule.get_name(), retypes[retype]).unwrap();
							} else {
								write!(f, "\t\tItem::Reduced(RuleId::{}, red) => red,\n", rule.get_name()).unwrap();
							};
						},
						ref x => panic!("unsupported symbol {:?}", x),
					}
					write!(f, "\t\tx => panic!(\"unexpected item {{:?}}\", x)\n").unwrap();
					write!(f, "\t}};\n").unwrap();
					i += 1;
				}

				if let Some(ref retype) = rule.get_reduced_type() {
					write!(f, "\tReduction::Ty{}(", retypes[retype]).unwrap();
				}
				write!(f, "{}(", redname).unwrap();
				for i in 0..var.symbols().len() {
					if i > 0 {
						write!(f, ", ").unwrap();
					}
					write!(f, "item{}", i).unwrap();
				}
				if rule.get_reduced_type().is_some() {
					write!(f, ")").unwrap();
				}
				write!(f, ")\n").unwrap();
			} else {
				let mut i = 0;
				let mut handled = false;
				for sym in var.symbols() {
					match *sym {
						Symbol::Terminal(_) => (),
						Symbol::NonTerminal(rule) => {
							write!(f, "\tmatch items.remove({}) {{\n", i).unwrap();
							write!(f, "\t\tItem::Reduced(RuleId::{}, red) => red,\n", rule.get_name()).unwrap();
							write!(f, "\t\tref x => panic!(\"unexpected item {{:?}}\", x)\n").unwrap();
							write!(f, "\t}}\n").unwrap();
							handled = true;
							break;
						},
						ref x => panic!("unsupported symbol {:?}", x),
					}
					i += 1;
				}

				if !handled {
					write!(f, "\tReduction::None\n").unwrap();
				}
			}
			write!(f, "}}\n").unwrap();
		}
	}


	write!(f, "\n// Rule Identifiers\n").unwrap();
	write!(f, "#[derive(Debug)]\n").unwrap();
	write!(f, "#[allow(non_camel_case_types)]\n").unwrap();
	write!(f, "enum RuleId {{\n").unwrap();
	for rule in grammar.rules() {
		write!(f, "\t{},\n", rule.get_name()).unwrap();
	}
	write!(f, "}}\n").unwrap();
}

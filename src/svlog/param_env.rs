// Copyright (c) 2016-2019 Fabian Schuiki

//! A parameter environment generated by an instantiation.

use crate::{
    crate_prelude::*,
    hir::{HirNode, NamedParam, PosParam},
};

/// A parameter environment.
///
/// This is merely an handle that is cheap to copy and pass around. Use the
/// [`Context`] to resolve this to the actual [`ParamEnvData`].
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ParamEnv(pub(crate) u32);

/// A parameter environment.
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash)]
pub struct ParamEnvData {
    values: Vec<(NodeId, ())>,
    types: Vec<(NodeId, ())>,
    garbage: String,
}

/// A location that implies a parameter environment.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum ParamEnvSource<'hir> {
    ModuleInst {
        module: NodeId,
        pos: &'hir [PosParam],
        named: &'hir [NamedParam],
    },
}

pub(crate) fn compute<'gcx>(
    cx: &impl Context<'gcx>,
    src: ParamEnvSource<'gcx>,
) -> Result<ParamEnv> {
    match src {
        ParamEnvSource::ModuleInst { module, pos, named } => {
            let module = match cx.hir_of(module)? {
                HirNode::Module(m) => m,
                _ => panic!("expected module"),
            };
            trace!("would now compute param env for {:?}", module);
            Ok(cx.intern_param_env(ParamEnvData {
                values: vec![],
                types: vec![],
                garbage: if pos.is_empty() && named.is_empty() {
                    Default::default()
                } else {
                    format!("{:?}; {:?}", pos, named)
                },
            }))
        }
    }
}

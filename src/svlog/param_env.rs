// Copyright (c) 2016-2019 Fabian Schuiki

//! A parameter environment generated by an instantiation.

use crate::{
    ast_map::AstNode,
    crate_prelude::*,
    hir::{HirNode, NamedParam, PosParam},
};

/// A parameter environment.
///
/// This is merely an handle that is cheap to copy and pass around. Use the
/// [`Context`] to resolve this to the actual [`ParamEnvData`].
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ParamEnv(pub(crate) u32);

/// A parameter environment.
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash)]
pub struct ParamEnvData {
    values: Vec<(NodeId, NodeId)>,
    types: Vec<(NodeId, NodeId)>,
}

/// A location that implies a parameter environment.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum ParamEnvSource<'hir> {
    ModuleInst {
        module: NodeId,
        pos: &'hir [PosParam],
        named: &'hir [NamedParam],
    },
}

pub(crate) fn compute<'gcx>(
    cx: &impl Context<'gcx>,
    src: ParamEnvSource<'gcx>,
) -> Result<ParamEnv> {
    match src {
        ParamEnvSource::ModuleInst { module, pos, named } => {
            let module = match cx.hir_of(module)? {
                HirNode::Module(m) => m,
                _ => panic!("expected module"),
            };

            // Associate the positional and named assignments with the actual
            // parameters of the module.
            let param_iter = pos
                .iter()
                .enumerate()
                .map(
                    |(index, &(span, assign_id))| match module.params.get(index) {
                        Some(&param_id) => Ok((param_id, assign_id)),
                        None => {
                            cx.emit(
                                DiagBuilder2::error(format!(
                                    "{} only has {} parameter(s)",
                                    module.desc_full(),
                                    module.params.len()
                                ))
                                .span(span),
                            );
                            Err(())
                        }
                    },
                )
                .chain(named.iter().map(
                    |&(span, name, assign_id)| match module.params.iter().find(|&&p| {
                        let param_name = match cx.ast_of(p) {
                            Ok(AstNode::TypeParam(_, p)) => Spanned::new(p.name.name, p.name.span),
                            Ok(AstNode::ValueParam(_, p)) => Spanned::new(p.name.name, p.name.span),
                            Ok(_) => unreachable!(),
                            Err(()) => return false,
                        };
                        param_name == name
                    }) {
                        Some(&param_id) => Ok((param_id, assign_id)),
                        None => {
                            cx.emit(
                                DiagBuilder2::error(format!(
                                    "{} has no parameter `{}`",
                                    module.desc_full(),
                                    name
                                ))
                                .span(span),
                            );
                            Err(())
                        }
                    },
                ));
            let param_iter = param_iter
                .collect::<Vec<_>>()
                .into_iter()
                .collect::<Result<Vec<_>>>()?
                .into_iter();

            // Split up type and value parameters.
            let mut types = vec![];
            let mut values = vec![];
            for (param_id, assign_id) in param_iter {
                match cx.ast_of(param_id)? {
                    AstNode::TypeParam(..) => types.push((param_id, assign_id)),
                    AstNode::ValueParam(..) => values.push((param_id, assign_id)),
                    _ => unreachable!(),
                }
            }

            Ok(cx.intern_param_env(ParamEnvData { types, values }))
        }
    }
}

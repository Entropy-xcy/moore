// Copyright (c) 2016-2020 Fabian Schuiki

//! A port mapping generated by an instantiation.

use crate::{
    crate_prelude::*,
    hir::{NamedParam, PosParam},
    port_list::ExtPort,
    ParamEnv,
};
use itertools::Itertools;
use std::sync::Arc;

/// A port mapping.
#[derive(Debug, Default, Clone, PartialEq, Eq, Hash)]
pub struct PortMapping<'a>(Vec<(Ref<'a, ExtPort<'a>>, NodeEnvId)>);

impl<'a> PortMapping<'a> {
    /// Find the signal assigned to a port.
    pub fn find(&self, node_id: NodeId) -> Option<NodeEnvId> {
        self.0
            .iter()
            .find(|&&(port, _)| port.id == node_id)
            .map(|&(_, id)| id)
    }

    /// Find the port a signal is assigned to.
    pub fn reverse_find(&self, node_id: NodeId) -> Option<&'a ExtPort<'a>> {
        self.0
            .iter()
            .find(|&&(_, id)| id.id() == node_id)
            .map(|&(Ref(port), _)| port)
    }
}

/// A location that implies a port mapping.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum PortMappingSource<'a> {
    ModuleInst {
        module: NodeId,
        inst: NodeId,
        /// The parameter environment around the instantiation.
        outer_env: ParamEnv,
        /// The parameter environment generated by the instantiation.
        inner_env: ParamEnv,
        pos: &'a [PosParam],
        named: &'a [NamedParam],
    },
}

/// Compute the port assignments for an instantiation.
#[moore_derive::query]
pub(crate) fn port_mapping<'a>(
    cx: &impl Context<'a>,
    src: PortMappingSource<'a>,
) -> Result<Arc<PortMapping<'a>>> {
    match src {
        PortMappingSource::ModuleInst {
            module,
            outer_env,
            pos,
            named,
            ..
        } => {
            let module = cx.ast_for_id(module).as_all().get_module().unwrap();
            let module_ports = cx.module_ports(module);

            // Associate the positional assignments with external ports.
            let pos_iter = pos.iter().enumerate().map(|(index, &(span, assign_id))| {
                match module_ports.ext_pos.get(index) {
                    Some(port) => Ok((port, assign_id)),
                    None => {
                        cx.emit(
                            DiagBuilder2::error(format!(
                                "{} only has {} ports(s)",
                                module,
                                module_ports.ext_pos.len()
                            ))
                            .span(span),
                        );
                        Err(())
                    }
                }
            });

            // Associate the named assignments with external ports.
            let named_iter = named.iter().map(|&(_span, name, assign_id)| {
                let names = match module_ports.ext_named.as_ref() {
                    Some(x) => x,
                    None => {
                        cx.emit(
                            DiagBuilder2::error(format!(
                                "{} requires positional connections",
                                module,
                            ))
                            .span(name.span)
                            .add_note(
                                "The module has unnamed ports which require connecting by \
                                 position.",
                            )
                            .add_note(format!("Remove `.{}(...)`", name)),
                        );
                        return Err(());
                    }
                };
                match names.get(&name.value) {
                    Some(&index) => Ok((&module_ports.ext_pos[index], assign_id)),
                    None => {
                        cx.emit(
                            DiagBuilder2::error(format!("no port `{}` in {}", name, module,))
                                .span(name.span)
                                .add_note(format!(
                                    "Declared ports are {}",
                                    module_ports
                                        .ext_pos
                                        .iter()
                                        .flat_map(|n| n.name)
                                        .map(|n| format!("`{}`", n))
                                        .format(", ")
                                )),
                        );
                        Err(())
                    }
                }
            });

            // Build a vector of ports.
            let ports: Result<Vec<_>> = pos_iter
                .chain(named_iter)
                .filter_map(|err| match err {
                    Ok((port, Some(assign_id))) => Some(Ok((Ref(port), assign_id.env(outer_env)))),
                    Ok(_) => None,
                    Err(()) => Some(Err(())),
                })
                .collect();

            Ok(Arc::new(PortMapping(ports?)))
        }
    }
}

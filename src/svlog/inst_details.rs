// Copyright (c) 2016-2020 Fabian Schuiki

//! A collection if instantiation details.

#[warn(missing_docs)]
use crate::{
    crate_prelude::*,
    hir::{self, HirNode},
    Context, ParamEnv, ParamEnvData, ParamEnvSource, PortMapping,
};
use std::{ops::Deref, sync::Arc};

/// Instantiation details
///
/// This struct bundles all the information associated with an instantiation,
/// most importantly the parameter bindings and port connections.
///
/// This corresponds to the `bar(y)` in `foo #(x) bar(y);`.
#[derive(Debug)]
pub struct InstDetails<'a> {
    /// The HIR instantiation.
    pub inst: &'a hir::Inst<'a>,
    /// The target details.
    pub target: Arc<InstTargetDetails<'a>>,
    /// The port connections.
    pub ports: Arc<PortMapping<'a>>,
}

impl<'a> Deref for InstDetails<'a> {
    type Target = InstTargetDetails<'a>;

    fn deref(&self) -> &Self::Target {
        self.target.as_ref()
    }
}

/// Instantiation target details
///
/// This struct bundles all the information associated with an instantiation
/// target, most importantly the parameter bindings.
///
/// This corresponds to the `foo #(x)` in `foo #(x) bar(y);`.
#[derive(Debug)]
pub struct InstTargetDetails<'a> {
    /// The HIR instantiation target.
    pub inst_target: &'a hir::InstTarget<'a>,
    /// The instantiated HIR module.
    pub kind: InstKind<'a>,
    /// The parameter environment around the instantiation.
    pub outer_env: ParamEnv,
    /// The parameter environment generated by the instantiation.
    pub inner_env: ParamEnv,
    /// The parameter bindings.
    pub params: &'a ParamEnvData<'a>,
}

/// Any HIR node that can be instantiated.
#[derive(Debug)]
pub enum InstKind<'a> {
    /// A kind instance.
    Module(&'a hir::Module<'a>),
    /// A interface instance.
    Interface(&'a hir::Interface<'a>),
}

impl<'a> InstKind<'a> {
    /// Get the ID of the instantiated node.
    pub fn id(&self) -> NodeId {
        match self {
            Self::Module(x) => x.id,
            Self::Interface(x) => x.id(),
        }
    }
}

/// Compute the details of an instantiation.
#[moore_derive::query]
pub(crate) fn inst_details<'a>(
    cx: &impl Context<'a>,
    Ref(inst): Ref<'a, hir::Inst<'a>>,
    env: ParamEnv,
) -> Result<Arc<InstDetails<'a>>> {
    // Look up the HIR of the instantiation.
    let inst_target = match cx.hir_of(inst.target)? {
        HirNode::InstTarget(x) => x,
        _ => unreachable!(),
    };

    // Determine the details of the instantiation target.
    let target = cx.inst_target_details(Ref(inst_target), env)?;

    // Determine the port connections of the instantiations. Connections
    // are made to the module's external ports, and must later be mapped
    // to the actual internal ports in a second step.
    let port_mapping = cx.port_mapping(
        match target.kind {
            InstKind::Module(node) => node.ast,
            InstKind::Interface(node) => node.ast,
        },
        target.outer_env,
        target.inner_env,
        &inst.pos_ports,
        &inst.named_ports,
    )?;

    // Wrap everything up.
    Ok(Arc::new(InstDetails {
        inst,
        target: target,
        ports: port_mapping,
    }))
}

/// Compute the details of an instantiated module or interface.
#[moore_derive::query]
pub(crate) fn inst_target_details<'a>(
    cx: &impl Context<'a>,
    Ref(inst_target): Ref<'a, hir::InstTarget<'a>>,
    env: ParamEnv,
) -> Result<Arc<InstTargetDetails<'a>>> {
    // Resolve the name of the instantiated module.
    let loc = cx.scope_location(inst_target.ast);
    let def = cx.resolve_local_or_error(inst_target.target, loc, false)?;
    trace!("Resolved instance `{}` to {:?}", inst_target.target, def);

    // Check what exactly we are instantiating.
    let target = match def.node {
        DefNode::Ast(ast) => match ast.as_all() {
            ast::AllNode::Module(x) => Some(InstKind::Module(cx.hir_of_module(x)?)),
            ast::AllNode::Interface(x) => Some(InstKind::Interface(cx.hir_of_interface(x)?)),
            _ => None,
        },
        _ => None,
    };
    let target = match target {
        Some(x) => x,
        None => {
            cx.emit(
                DiagBuilder2::error(format!(
                    "`{}` is not a module or interface",
                    inst_target.target
                ))
                .span(inst_target.target.span)
                .add_note(format!("{} was declared here:", def.node))
                .span(def.node.span()),
            );
            return Err(());
        }
    };

    // Create a new parameter environment that is generated by the
    // parametrization of this instance.
    let inst_env = cx.param_env(match target {
        InstKind::Module(node) => ParamEnvSource::ModuleInst {
            module: Ref(node),
            env,
            pos: &inst_target.pos_params,
            named: &inst_target.named_params,
        },
        InstKind::Interface(node) => ParamEnvSource::InterfaceInst {
            interface: Ref(node),
            env,
            pos: &inst_target.pos_params,
            named: &inst_target.named_params,
        },
    })?;
    let inst_env_data = cx.param_env_data(inst_env);

    // Wrap everything up.
    Ok(Arc::new(InstTargetDetails {
        inst_target,
        kind: target,
        outer_env: env,
        inner_env: inst_env,
        params: inst_env_data,
    }))
}

/// A visitor that emits instantiation details diagnostics.
pub struct InstVerbosityVisitor<'a, 'gcx> {
    cx: &'a GlobalContext<'gcx>,
    env: ParamEnv,
}

impl<'a, 'gcx> InstVerbosityVisitor<'a, 'gcx> {
    /// Create a new visitor that emits instantiation details.
    pub fn new(cx: &'a GlobalContext<'gcx>) -> Self {
        Self {
            cx,
            env: cx.default_param_env(),
        }
    }
}

impl<'a, 'gcx> hir::Visitor<'gcx> for InstVerbosityVisitor<'a, 'gcx> {
    type Context = GlobalContext<'gcx>;

    fn context(&self) -> &Self::Context {
        self.cx
    }

    fn visit_inst(&mut self, hir: &'gcx hir::Inst) {
        let details = match self.cx.inst_details(Ref(hir), self.env) {
            Ok(x) => x,
            Err(()) => return,
        };
        self.cx.emit(
            DiagBuilder2::note("instantiation details")
                .span(hir.name.span)
                .add_note(format!("{:#?}", details)),
        );
        Self {
            cx: self.cx,
            env: details.inner_env,
        }
        .visit_node_with_id(details.kind.id(), false);
    }
}

// Copyright (c) 2016 Fabian Schuiki

//! A preprocessor for SystemVerilog files that takes the raw stream of
//! tokens generated by a lexer and performs include and macro
//! resolution.

use std::path::Path;
use svlog::{lexer, token};
use errors::{DiagnosticBuilder, DiagResult, DUMMY_HANDLER};
use errors::{DiagResult2, DiagBuilder2};
use name::Name;
pub use svlog::token::Token;
use std::collections::HashMap;
use svlog::cat::*;
use lexer::{Lexer, AccumulatingReader, StackedLexer, BufferedLexer};
use std::fs::File;
use source::*;
use std::rc::Rc;
use owning_ref::RcRef;



pub struct Preprocessor<'a> {
	stack: Vec<Stream<'a>>,
	contents: Vec<Rc<SourceContent>>,
	token: Option<TokenAndSpan>,
	/// The defined macros.
	macro_defs: HashMap<String, Vec<TokenAndSpan>>,
	/// The stack used to inject expanded macros into the token stream.
	macro_stack: Vec<TokenAndSpan>,
}

type TokenAndSpan = (CatTokenKind, Span);

struct Stream<'a> {
	source: Source,
	content: &'a SourceContent,
	iter: Cat<'a>,
}

impl<'a> Preprocessor<'a> {
	/// Create a new preprocessor for the given source file.
	pub fn new(source: Source) -> Preprocessor<'a> {
		let content = source.get_content();
		let content_unbound = unsafe { &*(content.as_ref() as *const SourceContent) };
		let iter = content_unbound.iter();
		Preprocessor {
			stack: vec![Stream {
				source: source,
				content: content_unbound,
				iter: Cat::new(iter)
			}],
			contents: vec![content],
			token: None,
			macro_defs: HashMap::new(),
			macro_stack: Vec::new(),
		}
	}

	/// Advance to the next token in the input stream.
	fn bump(&mut self) {
		self.token = self.macro_stack.pop();
		if self.token.is_some() {
			return
		}
		loop {
			self.token = match self.stack.last_mut() {
				Some(stream) => stream.iter.next().map(|tkn| (tkn.0, Span::new(stream.source, tkn.1, tkn.2))),
				None => return,
			};
			if self.token.is_none() {
				self.stack.pop();
			} else {
				break;
			}
		}
	}

	fn handle_directive<S: AsRef<str>>(&mut self, dir: S, span: Span) -> DiagResult2<()> {
		let dir = dir.as_ref();
		// println!("Handling directive {}, over {:?}", dir, span);

		if dir == "include" {
			// Skip leading whitespace.
			self.bump();
			match self.token {
				Some((Whitespace, _)) => self.bump(),
				_ => ()
			}

			// Match the opening double quotes or angular bracket.
			let name_p;
			let name_q;
			let closing = match self.token {
				Some((Symbol('"'), sp)) => { name_p = sp.end(); self.bump(); '"' },
				Some((Symbol('<'), sp)) => { name_p = sp.end(); self.bump(); '>' },
				_ => { return Err(DiagBuilder2::fatal("Expected filename inside double quotes (\"...\") or angular brackets (<...>) after `include").span(span))}
			};

			// Accumulate the include path until the closing symbol.
			let mut filename = String::new();
			loop {
				match self.token {
					Some((Symbol(c), sp)) if c == closing => {
						name_q = sp.begin();
						break;
					},
					Some((Newline, sp)) => {
						return Err(DiagBuilder2::fatal("Expected end of included file's name before line break").span(sp));
					},
					Some((_, sp)) => {
						filename.push_str(&sp.extract());
						self.bump();
					},
					None => {
						return Err(DiagBuilder2::fatal("Expected filename after `include directive before the end of the input").span(span));
					}
				}
			}

			// Create a new lexer for the included filename and push it onto the
			// stream stack.
			println!("including file \"{}\"", filename);
			let included_source = match get_source_manager().open(&filename) {
				Some(src) => src,
				None => {
					return Err(
						DiagBuilder2::fatal(format!("Cannot open included file \"{}\"", filename))
						.span(Span::union(name_p, name_q))
					);
				}
			};
			println!("including file {:?}", included_source);

			let content = included_source.get_content();
			let content_unbound = unsafe { &*(content.as_ref() as *const SourceContent) };
			let iter = content_unbound.iter();
			self.contents.push(content);
			self.stack.push(Stream {
				source: included_source,
				content: content_unbound,
				iter: Cat::new(iter)
			});

			return Ok(());
		}

		if dir == "define" {
			// Skip leading whitespace.
			self.bump();
			match self.token {
				Some((Whitespace, _)) => self.bump(),
				_ => ()
			}

			// Consume the macro name.
			let (name, name_span) = match self.token {
				Some((Text, sp)) => (sp.extract(), sp),
				_ => return Err(DiagBuilder2::fatal("Expected macro name after `define").span(span))
			};
			self.bump();

			// Skip whitespace between the macro name and potential parameters.
			match self.token {
				Some((Whitespace, _)) => self.bump(),
				_ => ()
			}

			// Consume the macro arguments and parameters.
			match self.token {
				Some((Symbol('('), _)) =>
					return Err(DiagBuilder2::fatal("Macros with parameters not yet implemented").span(span)),
				_ => ()
			}

			// Consume the macro definition up to the next newline not preceded
			// by a backslash, ignoring comments, whitespace and newlines.
			let mut body = Vec::new();
			loop {
				match self.token {
					Some((Newline, _)) => { break; },
					Some((Whitespace, _)) => self.bump(),
					Some((Comment, _)) => self.bump(),
					Some((Symbol('\\'), _)) => {
						self.bump();
						match self.token {
							Some((Newline, _)) => self.bump(),
							_ => ()
						};
					},
					Some(x) => {
						body.push(x);
						self.bump();
					},
					None => break,
				}
			}
			println!("PREPROC: defining macro {} with {} tokens", name, body.len());

			self.macro_defs.insert(name, body);
			return Ok(());
		}

		if let Some(ref body) = self.macro_defs.get(dir) {
			println!("PREPROC: substituting macro {}", dir);
			for x in body.iter().rev() {
				self.macro_stack.push(*x);
			}
			Ok(())
		} else {
			return Err(
				DiagBuilder2::fatal(format!("Unknown compiler directive '`{}'", dir))
				.span(span)
			);
		}

		// panic!("Unknown compiler directive '`{}'", dir);
		// Ok(())
	}
}

impl<'a> Iterator for Preprocessor<'a> {
	type Item = DiagResult2<TokenAndSpan>;

	fn next(&mut self) -> Option<DiagResult2<TokenAndSpan>> {
		if self.token.is_none() {
			self.bump();
		}
		loop {
			match self.token {
				Some((Symbol('`'), sp_backtick)) => {
					self.bump();
					match self.token {
						Some((Text, sp)) => {
							let dir_span = Span::union(sp_backtick, sp);
							match self.handle_directive(sp.extract(), dir_span) {
								Err(x) => return Some(Err(x)),
								_ => ()
							}
							self.bump();
							continue;
						}
						_ => {
							return Some(
								Err(DiagBuilder2::fatal("Expected compiler directive after '`'")
								.span(sp_backtick)
							));
						}
					}
				}
				_ => {
					let tkn = self.token.map(|x| Ok(x));
					self.bump();
					return tkn;
				}
			}
		}
	}
}



#[cfg(test)]
mod tests {
	use super::*;
	use source::*;

	#[test]
	fn include_and_define() {
		let sm = get_source_manager();
		sm.add("other.sv", "/* World */\n`define foo 42\n");
		sm.add("test.sv", "// Hello\n`include \"other.sv\"\n`foo something\n");
		let mut pp = Preprocessor::new(sm.open("test.sv").unwrap());
		let actual: String = pp.map(|x| x.unwrap().1.extract()).collect();
		let expected = "// Hello\n/* World */\n\n42 something\n";
		assert_eq!(actual, expected);
	}
}

Names
-----

primary_name:
	ident
	char_lit
	string_lit

name:
	primary_name
	name "." ident               # selected_name
	name "." char_lit            # selected_name
	name "." string_lit          # selected_name
	name "." "all"               # selected_name
	name [signature] "'" ident   # attribute_name, range
	name paren_expr              # func_call, slice_name, indexed_name, array_constraint, record_constraint, elem_constraint, elem_resol, assoc_list
	name "range" expr            # range_constraint, index_subtype_definition


Expressions
-----------

primary_expr:
	name                           # name, func_call, type_conv, physical_lit, enum_lit, subtype_ind, resol_ind
	name name                      # subtype_ind/resol_ind, elem_resol
	name "'" paren_expr            # qualified_expr
	abstract_lit
	abstract_lit name              # physical_lit
	bit_string_lit
	"null"
	"open"                         # array_constraint
	"others"                       # assoc_list
	"<>"                           # index_subtype_definition, intf_pkg_generic_map_aspect
	"default"                      # intf_pkg_generic_map_aspect
	paren_expr                     # aggregate, (expr), resol_ind
	paren_expr name                # subtype_ind/resol_ind
	"new" name                     # alloc/subtype_ind
	"new" name name                # alloc/subtype_ind
	"new" paren_expr name          # alloc/subtype_ind
	"new" name "'" paren_expr      # alloc/qualified_expr

paren_expr:
	"(" { [ { expr }"|"+ "=>" ] expr }","+ ")"  # aggregate, elem_resol, assoc_list, assoc_elem, formal_part, actual_part, formal_desig, array_constraint, record_constraint, name, subtype_ind, range, slice_name

expr:
	[ 0] primary_expr
	[ 1] "abs" expr[0]
	[ 1] "not" expr[0]
	[ 1] logical_op expr[0]
	[ 1] expr[0] "**" expr[0]       # enforce non-associativity later
	[ 2] expr[2] mult_op expr[1]
	[ 3] sign expr[2]
	[ 4] expr[4] add_op expr[3]     # enforce sign/term stuff later
	[ 5] expr[4] dir expr[4]        # range
	[ 6] expr[6] shift_op expr[5]   # enforce non-associativity later
	[ 7] expr[7] rel_op expr[6]     # enforce non-associativity later
	[ 8] expr[8] logical_op expr[7] # enforce non-associativity for nand/nor later
	[ 9] "??" expr[0]
	[10] "inertial" expr[9]        # actual_part


Resolution Indication
---------------------

resol_ind:
	name
	paren_expr

elem_resol:
	resol_ind
	{ simple_name name }","+
	{ simple_name paren_expr }","+


Subtypes
--------

subtype_ind:
	name                      # array_constraint, record_constraint, elem_constraint, range_constraint
	name name                 # array_constraint, record_constraint, elem_constraint, range_constraint
	paren_expr name           # array_constraint, record_constraint, elem_constraint, range_constraint
	-> ";" "," ")" ":=" "register" "bus" "open" "is" ">>" mult_op add_op shift_op rel_op logical_op "**"


Declarative Items
-----------------

- [x] subprogram_declaration                "procedure" "pure" "impure" "function"
- [x] subprogram_body                       "procedure" "pure" "impure" "function"
- [x] subprogram_instantiation_declaration  "procedure" "function"
- [x] package_declaration                   "package"
- [x] package_body                          "package body"
- [x] package_instantiation_declaration     "package"
- [x] type_declaration                      "type"
- [x] subtype_declaration                   "subtype"
- [x] constant_declaration                  "constant"
- [x] variable_declaration                  "shared" "variable"
- [x] signal_declaration                    "signal"
- [x] file_declaration                      "file"
- [x] alias_declaration                     "alias"
- [x] component_declaration                 "component"
- [ ] attribute_declaration                 "attribute"
- [ ] attribute_specification               "attribute"
- [ ] configuration_specification           "for"
- [x] disconnection_specification           "disconnect"
- [x] use_clause                            "use"
- [ ] group_template_declaration            "group"
- [ ] group_declaration                     "group"


Type Definitions
----------------

type_def
	- scalar_type_def
		- enum_type_def
		- integer_type_def
		- floating_type_def
		- physical_type_def
	- composite_type_def
		- array_type_def
		- record_type_def
	- access_type_def
	- file_type_def
	- protected_type_def
		- protected_type_decl
		- protected_type_body

paren_expr                                                            # enum_type_def
"range" range                                                         # integer_type_def/floating_type_def
"range" range units_decl                                              # physical_type_def
"array" paren_expr "of" subtype_ind                                   # array_type_def
"record" { {ident}","+ ":" subtype_ind ";" }+ "end" "record" [ident]  # record_type_def
"access" subtype_ind                                                  # access_type_def
"file" "of" name                                                      # file_type_def
protected_type_decl                                                   # protected_type_def
protected_type_body                                                   # protected_type_def

units_decl := "units" {ident ["=" [abstract_lit] name] ";"}+ "end" "units" [ident]
protected_type_decl :=
	"protected"
		{decl_item}
	"end" "protected" [ident]
protected_type_body :=
	"protected" "body"
		{decl_item}
	"end" "protected" "body" [ident]


Subprograms
-----------

subprog_decl := subprog_spec ";"
subprog_body := subprog_spec "is" {decl_item} "begin" {stmt} "end" ["procedure"|"function"] [name] ";"
subprog_inst := subprog_spec "is" "new" name [signature] [generic_map_aspect] ";"
intf_subprog_decl
	:= subprog_spec
	:= subprog_spec "is" name|"<>"

subprog_spec :=
	["pure"|"impure"] "procedure"|"function"
	primary_name
	["generic" paren_expr]
	["generic" "map" paren_expr]
	[["parameter"] paren_expr]
	["return" name]

# Copyright (c) 2016 Fabian Schuiki
# VHDL Grammar as per IEEE 1076-2000

# Keyword Terminals
@tokenlist "Token::Keyword(Keyword::@)" {
	ABS "Abs";
	ACCESS "Access";
	AFTER "After";
	ALIAS "Alias";
	ALL "All";
	AND "And";
	ARCHITECTURE "Architecture";
	ARRAY "Array";
	ASSERT "Assert";
	ASSUME "Assume";
	ASSUME_GUARANTEE "AssumeGuarantee";
	ATTRIBUTE "Attribute";
	BEGIN "Begin";
	BLOCK "Block";
	BODY "Body";
	BUFFER "Buffer";
	BUS "Bus";
	CASE "Case";
	COMPONENT "Component";
	CONFIGURATION "Configuration";
	CONSTANT "Constant";
	CONTEXT "Context";
	COVER "Cover";
	DEFAULT "Default";
	DISCONNECT "Disconnect";
	DOWNTO "Downto";
	ELSE "Else";
	ELSIF "Elsif";
	END "End";
	ENTITY "Entity";
	EXIT "Exit";
	FAIRNESS "Fairness";
	FILE "File";
	FOR "For";
	FORCE "Force";
	FUNCTION "Function";
	GENERATE "Generate";
	GENERIC "Generic";
	GROUP "Group";
	GUARDED "Guarded";
	IF "If";
	IMPURE "Impure";
	IN "In";
	INERTIAL "Inertial";
	INOUT "Inout";
	IS "Is";
	LABEL "Label";
	LIBRARY "Library";
	LINKAGE "Linkage";
	LITERAL "Literal";
	LOOP "Loop";
	MAP "Map";
	MOD "Mod";
	NAND "Nand";
	NEW "New";
	NEXT "Next";
	NOR "Nor";
	NOT "Not";
	NULL "Null";
	OF "Of";
	ON "On";
	OPEN "Open";
	OR "Or";
	OTHERS "Others";
	OUT "Out";
	PACKAGE "Package";
	PARAMETER "Parameter";
	PORT "Port";
	POSTPONED "Postponed";
	PROCEDURE "Procedure";
	PROCESS "Process";
	PROPERTY "Property";
	PROTECTED "Protected";
	PURE "Pure";
	RANGE "Range";
	RECORD "Record";
	REGISTER "Register";
	REJECT "Reject";
	RELEASE "Release";
	REM "Rem";
	REPORT "Report";
	RESTRICT "Restrict";
	RESTRICT_GUARANTEE "RestrictGuarantee";
	RETURN "Return";
	ROL "Rol";
	ROR "Ror";
	SELECT "Select";
	SEQUENCE "Sequence";
	SEVERITY "Severity";
	SHARED "Shared";
	SIGNAL "Signal";
	SLA "Sla";
	SLL "Sll";
	SRA "Sra";
	SRL "Srl";
	STRONG "Strong";
	SUBTYPE "Subtype";
	THEN "Then";
	TO "To";
	TRANSPORT "Transport";
	TYPE "Type";
	UNAFFECTED "Unaffected";
	UNITS "Units";
	UNTIL "Until";
	USE "Use";
	VARIABLE "Variable";
	VMODE "Vmode";
	VPROP "Vprop";
	VUNIT "Vunit";
	WAIT "Wait";
	WHEN "When";
	WHILE "While";
	WITH "With";
	XNOR "Xnor";
	XOR "Xor";
}

# Symbol Terminals
@tokenlist "Token::Symbol(Symbol::@)" {
	LPAREN "LParen";
	RPAREN "RParen";
	LBRACK "LBrack";
	RBRACK "RBrack";
	LBRACE "LBrace";
	RBRACE "RBrace";
	LARROW "LArrow";
	RARROW "RArrow";
	APOSTROPHE "Apostrophe";
	COLON "Colon";
	SEMICOLON "Semicolon";
	PERIOD "Period";
	COMMA "Comma";
	EQUAL "Equal";
	ADD "Add";
	SUB "Sub";
	MUL "Mul";
	DIV "Div";
	LT "Lt";
	GT "Gt";
}

@token IDENT "Token::Ident(_)";
@token EXTIDENT "Token::ExtIdent(_)";
@token INTEGER "Token::Integer(_)";
@token REAL "Token::Real(_,_,_)";
@token BASEDINTEGER "Token::BasedInteger(_,_)";
@token BASEDREAL "Token::BasedReal(_,_,_,_)";
@token CHARLITERAL "Token::CharLiteral(_)";
@token STRINGLITERAL "Token::StringLiteral(_)";

@root design_file;

design_file : design_unit_list ;

# 1.1 Entity declarations
entity_decl_p0 "Box<Entity>" : ENTITY IDENT IS > start_entity;
entity_decl_p1 "Box<Entity>"
	: entity_decl_p0 GENERIC LPAREN intf_list RPAREN > add_entity_generic
	| entity_decl_p0 ;
entity_decl_p2 "Box<Entity>"
	: entity_decl_p1 PORT LPAREN intf_list RPAREN > add_entity_port
	| entity_decl_p1 ;
entity_decl_p3 "Box<Entity>" : entity_decl_p2 entity_decl_part;
entity_decl_p4 : entity_decl_p3 | entity_decl_p0 BEGIN entity_stmt_part ;
entity_decl_p5 : entity_decl_p4 END ;
entity_decl_p6 : entity_decl_p5 ENTITY ;
entity_decl_p7 : entity_decl_p6 simple_name ;
entity_decl "Box<Entity>" : entity_decl_p7 SEMICOLON ;

# 1.1.1 Entity header
# generic_clause : GENERIC LPAREN intf_list RPAREN ;
# port_clause : PORT LPAREN intf_list RPAREN ;

entity_decl_part : entity_decl_item | entity_decl_part entity_decl_item ;
entity_decl_item ;

entity_stmt_part : entity_stmt | entity_stmt_part entity_stmt ;
entity_stmt ;

# 1.2 Architecture bodies
arch_body_p0 : ARCHITECTURE IDENT OF name IS arch_decl_part BEGIN arch_stmt_part END;
arch_body_p1 : arch_body_p0 | arch_body_p0 ARCHITECTURE ;
arch_body_p2 : arch_body_p1 | arch_body_p1 simple_name ;
arch_body : arch_body_p2 SEMICOLON ;

arch_decl_part;
arch_stmt_part;



# ------------------------------------------------------------------------------
# 3 Types
# ------------------------------------------------------------------------------

# 3.1 Scalar types
scalar_typedef
	: enum_typedef
	| int_typedef
	| physical_typedef
	| float_typedef
	;

range_constraint : RANGE range ;
range : simple_expr direction simple_expr;
direction "Direction"
	: TO > reduce_direction
	| DOWNTO > reduce_direction
	;

# 3.1.1 Enumeration types
enum_typedef "TypeDef" : LPAREN enum_literal_list RPAREN > reduce_enum_typedef;
enum_literal_list "Vec<EnumLiteral>"
	: enum_literal > start_enum_literal_list
	| enum_literal_list COMMA enum_literal > extend_enum_literal_list
	;
enum_literal "EnumLiteral"
	: IDENT > reduce_enum_literal
	| CHARLITERAL > reduce_enum_literal
	;

# 3.1.2 Integer types
int_typedef "TypeDef" : range_constraint > reduce_int_typedef;

# 3.1.3 Physical types
physical_typedef;

# 3.1.4 Floating point types
float_typedef;


# 3.2 Composite types
composite_typedef
	: array_typedef
	| record_typedef
	;

# 3.2.1 Array types
array_typedef "TypeDef"
	: unconstr_array_def
	| constr_array_def
	;

unconstr_array_def "TypeDef" : ARRAY LPAREN index_subtypedef_list RPAREN OF subtype_indication > reduce_unconstr_array_def;
constr_array_def "TypeDef" : ARRAY index_constraint OF subtype_indication > reduce_constr_array_def;

index_subtypedef_list
	: index_subtypedef > start_subtypedef_list
	| index_subtypedef_list COMMA index_subtypedef > extend_subtypedef_list
	;

index_subtypedef : type_mark RANGE LT GT > reduce_subtypedef;
index_constraint : LPAREN discrete_range_list RPAREN > reduce_index_constr;

discrete_range_list
	: discrete_range
	| discrete_range_list COMMA discrete_range
	;
discrete_range
	: subtype_indication
	| range
	;

# 3.2.2 Record types
record_typedef_p0 "TypeDef" : RECORD element_decl > start_record_typedef;
record_typedef_p1 "TypeDef" : record_typedef_p0 | record_typedef_p0 element_decl > extend_record_typedef;
record_typedef_p2 "TypeDef" : record_typedef_p1 END RECORD;
record_typedef "TypeDef"
	: record_typedef_p2 > finish_record_typedef
	| record_typedef_p2 simple_name > finish_record_typedef_check
	;

element_decl : ident_list COLON subtype_indication SEMICOLON > reduce_element_decl;


# 3.3 Access Types
access_typedef "TypeDef" : ACCESS subtype_indication > reduce_access_typedef;


# 3.4 File types
file_typedef : FILE OF type_mark > reduce_file_typedef;


# 3.5 Protected types
protected_typedef ;



# ------------------------------------------------------------------------------
# 4 Declarations
# ------------------------------------------------------------------------------

decl "Decl" : type_decl | subtype_decl;


# 4.1 Type declarations
type_decl "TypeDecl"
	: TYPE IDENT IS typedef SEMICOLON > reduce_typedecl
	| TYPE IDENT SEMICOLON > reduce_incomplete_typedecl
	;

typedef : scalar_typedef | composite_typedef | access_typedef | file_typedef | protected_typedef;


# 4.2 Subtype declarations
subtype_decl "SubtypeDecl" : SUBTYPE IDENT IS subtype_indication > reduce_subtypedecl;

subtype_indication_p0 "SubtypeIndication"
	: name type_mark > start_subtype_indication_with_resfun
	| name > start_subtype_indication
	;
subtype_indication "SubtypeIndication" : subtype_indication_p0 | subtype_indication_p0 constraint > set_subtype_indication_constraint;

type_mark : name;

constraint : range_constraint | index_constraint ;



array_constraint : LPAREN range RPAREN ;


# 4.3.2 Interface declarations
intf_decl "Box<IntfDecl>"
	: intf_signal_decl
	;

intf_signal_decl "Box<IntfDecl>" : ident_list COLON mode subtype_indication > reduce_intf_signal_decl;

mode "Mode"
	: IN > reduce_mode
	| OUT > reduce_mode
	| INOUT > reduce_mode
	| BUFFER > reduce_mode
	| LINKAGE > reduce_mode
	;
intf_list "Vec<Box<IntfDecl>>" : intf_decl | intf_list SEMICOLON intf_decl;
ident_list "Vec<String>"
	: IDENT > start_ident_list
	| ident_list COMMA IDENT > extend_ident_list
	;



# ------------------------------------------------------------------------------
# 6 Names
# ------------------------------------------------------------------------------

# 6.1 Names
name "Name" : simple_name | operator_symbol | selected_name | indexed_name | slice_name | attribute_name;
prefix : name | function_call;


# 6.2 Simple names
simple_name "Name" : IDENT > reduce_simple_name ;


# 6.3 Selected names
selected_name "Name"
	: prefix PERIOD simple_name > reduce_selected_name_simple
	| prefix PERIOD CHARLITERAL > reduce_selected_name_charlit
	| prefix PERIOD operator_symbol > reduce_selected_name_opsym
	| prefix PERIOD ALL > reduce_selected_name_all
	;


# 6.4 Indexed names
indexed_name "Name" : prefix LPAREN expr_list RPAREN > reduce_indexed_name;
expr_list "Vec<Expr>" : expr > start_expr_list | expr_list COMMA expr > extend_expr_list;


# 6.5 Slice names
slice_name "Name" : prefix LPAREN discrete_range RPAREN > reduce_slice_name;


# 6.6 Attribute names
attr_name;



# ------------------------------------------------------------------------------
# 10 Scope and visibility
# ------------------------------------------------------------------------------

# 10.4 Use clauses
use_clause_p0 : USE selected_name | use_clause COMMA selected_name ;
use_clause : use_clause_p0 SEMICOLON ;



# ------------------------------------------------------------------------------
# 11 Design units and their analysis
# ------------------------------------------------------------------------------

# 11.1 Design units
design_unit_list : design_unit | design_unit_list design_unit ;
design_unit : library_unit | context_clause library_unit ;
library_unit : entity_decl | config_decl | pkg_decl | arch_body | pkg_body ;


# 11.2 Design libraries
library_clause : LIBRARY library_name_list SEMICOLON > reduce_library_clause ;
library_name_list "Vec<String>" : IDENT > reduce_library_name_list_x | library_name_list COMMA IDENT > reduce_library_name_list_xs ;


# 11.3 Context clauses
context_clause : context_item > start_context_clause | context_clause context_item > extend_context_clause;
context_item : library_clause | use_clause ;



# Missing
expr;
config_decl;
pkg_decl;
pkg_body;
operator_symbol;
attribute_name;
function_call;
simple_expr;
